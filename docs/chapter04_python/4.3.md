# 4.3 使用python 整理的项目
## 4.3.1使用python 整理的612项目
### 1.复制功能：一个视频，知道了每个目标的起始帧和结束帧，将每个目标单独的图片放在文件夹

思路：
1.首先将视频转成图片
2.根据起始帧和结束帧复制图片

video_path:视频路径
im_dir: 存储图片目录
im_type="jpg"：存储图片类型，默认.jpg
im_name_mode=0：文件命名格式，默认1.jpg

```python
import cv2
import pandas as pd
import os
import shutil

# 视频转图片
def video2im(video_path,im_dir,im_type="jpg",im_name_mode=0):
    cap=cv2.VideoCapture(video_path)
    i=1
    while True:
        ret,im=cap.read()
        if ret==True:
            if(im_name_mode=="0"):
                im_name=str(i)+"."+im_type
            #else:
            #im_name='{:0>{1}s}'.format(str(i),im_name_mode)+"."+im_type
            im_name = '{0:0>{1}}'.format(str(i),im_name_mode) + "." + im_type
            im_path=os.path.join(im_dir,im_name)
            cv2.imwrite(im_path,im)
        else:
            break
        i=i+1
        
video_name=1    #视频编号
video_path=r"E:\MyProjects\sampletest\1.avi"    #视频路径
im_dir=r"E:\MyProjects\sampletest\1"    #图片目录
frames_info_path=r"E:\MyProjects\sampletest\1\objs_frame_info.txt" #存放帧信息txt

# 1. 视频转图片
im_list = []  # 新建空链表
for item in os.listdir(im_dir):
    if (item.endswith('.jpg')):
        im_list.append(item)
if im_list:
    print("There is exist picture")
else:
    video2im(video_path, im_dir, "jpg", 4)

# 2. 读取目标帧信息
objs_frame_info= pd.read_csv(frames_info_path,sep=' ', index_col='object_num')
objs_num=objs_frame_info.shape[0]  #行,目标个数

# 3. 创建图片目录，例：E:\MyProjects\sampletest\1\1_1\img\
for obj_num in range(1,objs_num+1):
    obj_dir=os.path.join(im_dir,str(video_name)+"_"+str(obj_num),'img')
    if not os.path.exists(obj_dir):
        os.makedirs(obj_dir)
    else:
        print("There is exist obj_dir")

# 4. 将图片的名字按顺序存放到列表，例：0001.jpg 0002.jpg
im_list = []  # 新建空链表
for item in os.listdir(im_dir):
    if (item.endswith('.jpg')):  # 如果是.jpg文件，则放到filelist
           im_list.append(item)
im_list.sort(key=lambda x:int(x[:-4]))

# 5. 根据帧信息拷贝图片到相应目录
for item in im_list:
    (im_name, extension)=os.path.splitext(item)
    cur_frame=int(im_name)
    for obj_num in range(1, objs_num + 1):
        if cur_frame >= objs_frame_info.loc[obj_num, "start_frame"] and cur_frame <= objs_frame_info.loc[obj_num, "end_frame"]:
            src_im_path=os.path.join(im_dir,item)
            dst_im_path=os.path.join(im_dir,str(video_name)+"_"+str(obj_num),'img',item)
            if os.path.exists(src_im_path) and  not os.path.exists(dst_im_path):
                shutil.copy(src_im_path,dst_im_path)
            elif not os.path.exists(src_im_path):
                print("There isn't exist src_im_path")
                break;
            elif os.path.exists(dst_im_path):
                print("There is exist dst_im_path")
                break;
```

### 2. 为视频的第一帧画框，存储
- 根据每个目标的开始帧和结束帧，复制图片到单独的文件夹里，并重命名%04d.jpg (从0001.jpg开始)
- 显示每个目标的第一帧图，为目标画框，得到第一帧目标的xywh，并存储
- 作用是为直接使用ECO做准备

```python
import cv2
import numpy as np
import pandas as pd
import os

#  吊舱的测试视频有11个，这里选择是第几个视频，保存为num
video_num=1
num=video_num

#  视频存放的路径，一般得到的结果也存储到这个文件夹里，所以设置为主路径，也叫做视频的路径，因为这里主目录就是视频存放的目录
main_dir=r"E:\work\zmvision\12suo\videosamples"
video_dir=main_dir

#  读取每个目标的起始帧和结束帧的信息，先获取文本路径，再读取
info_stendframes_path=os.path.join(video_dir,'info_stendframes.txt')
info_stendframes=pd.read_csv(info_stendframes_path, sep=' |\t',index_col='object_num')

#  得到有多少个目标
sub_num=info_stendframes.shape[0]
#  print(sub_num)

#  为每个目标创建单独的文件夹，用于储存结果
for i in range(1,sub_num+1):
    if not os.path.exists(os.path.join(main_dir,str(num),str(num)+'_'+str(i),'img')):
        os.makedirs(os.path.join(main_dir,str(num),str(num)+'_'+str(i),'img'))

#  为每个目标定义一个p，用于得到在当前目标的第几帧
for i in range(1,sub_num+1):
    locals()['p'+str(i)]=1

#  获取视频，并得到视频的总帧数
capture = cv2.VideoCapture(os.path.join(video_dir,str(num)+'.avi'))
frames_num=capture.get(7)

#  遍历原始视频的每一帧，将相应的帧的图片复制到每个目标对应的文件夹
for i in range(1,int(frames_num)+1):
    ret,frame = capture.read()

    #  遍历每个目标，如果该帧的编号在某个目录的起始帧和结束帧中间，则写入
    #  用p来记录每个目标复制到哪一帧了（p从1开始）
    for num_object in range(1, sub_num + 1):
        if i>=info_stendframes.loc[num_object, "start_frame"] and i<info_stendframes.loc[num_object, "end_frame"]:
            p = locals()['p' + str(num_object)]
            #  将图片写入
            cv2.imwrite(os.path.join(r"E:\work\zmvision\12suo\videosamples",str(num),str(num)+'_'+str(num_object),'img',"%04d.jpg"%p), frame)
            locals()['p' + str(num_object)] = locals()['p' + str(num_object)] + 1

drawing = False
ix, iy,w,h = -1, -1,-1,-1
tempFlag = False
def draw_circle(event, x, y, flags, param):
    global ix, iy, drawing, mode, cap, template, tempFlag,w,h
    if event == cv2.EVENT_LBUTTONDOWN:
        tempFlag = True
        drawing = True
        ix, iy = x, y                        #  按下鼠标左键，用全局变量ix,iy记录下当前坐标点
        print("ix: "+ix)
        print("iy: "+iy)
    elif event== cv2.EVENT_LBUTTONUP:
        if drawing == True:
            drawing = False                  #  鼠标左键抬起，画出矩形框
            w=x-ix
            h=y-iy
            cv2.rectangle(frame,(ix,iy),(x,y),(0,255,0),1)
            print("w: "+w)
            print("h: "+h)

#  新建窗口。遍历每个目标的第一幅图像，画框，存储他们的起始坐标
cv2.namedWindow('0001')
cv2.setMouseCallback('0001',draw_circle)
for num_object in range(1, sub_num + 1):
    frame=cv2.imread(os.path.join(r"E:\work\zmvision\12suo\videosamples",str(num),str(num)+'_'+str(num_object),'img',"0001.jpg"))
    while True:
        cv2.imshow("0001",frame)
        k=cv2.waitKey(33)
        if k==32:
            break
        elif k==27 :
            frame = cv2.imread(os.path.join(r"E:\work\zmvision\12suo\videosamples", str(num), str(num) + '_' + str(num_object), 'img',
                             "0001.jpg"))
    f=open(os.path.join(r"E:\work\zmvision\12suo\videosamples",str(num),str(num)+'_'+str(num_object),"groundtruth_rect.txt"),'w')
    f.write('{0} {1} {2} {3}\n{4}'.format(ix,iy,w,h,locals()['p' + str(num_object)]-1))
    f.close()
```

### 3.视频根据起始帧和结束帧转图片
- 一个视频，知道了每个目标的起始帧和结束帧，将每个目标单独的图片放在文件夹
- 首先将视频转成图片
- 根据起始帧和结束帧复制图片

```python
import cv2
import pandas as pd
import os
import shutil


im=0
drawing = False
x_lt,y_lt,w,h=-1,-1,-1,-1
def draw_circle(event, x, y, flags, param):
    global x_lt,y_lt,w,h,drawing,im
    if event == cv2.EVENT_LBUTTONDOWN:
        drawing = True
        x_lt, y_lt = x, y                        #  按下鼠标左键，用全局变量ix,iy记录下当前坐标点
        print(str(x_lt))
        print(str(y_lt))

    elif event== cv2.EVENT_LBUTTONUP:
        if drawing == True:
            drawing = False                  #  鼠标左键抬起，画出矩形框
            w=x-x_lt
            h=y-y_lt
            cv2.rectangle(im,(x_lt,y_lt),(x,y),(0,255,0),1)
            print(str(x))
            print(str(y))

def draw_init_pos(im_dir):
    global im
    im_list = []  # 新建空链表
    for item in os.listdir(im_dir):
        if (item.endswith('.jpg')):
            im_list.append(item)
    im_list.sort(key=lambda x: int(x[:-4]))

    cv2.namedWindow(im_list[0])
    cv2.setMouseCallback(im_list[0], draw_circle)

    im_path=os.path.join(im_dir,im_list[0])
    im=cv2.imread(im_path)

    while True:
        cv2.imshow(im_list[0], im)
        k = cv2.waitKey(33)
        if k == 32:
            cv2.destroyWindow(im_list[0])
            break
        elif k == 27:
            im = cv2.imread(im_path)



video_name=1    #视频编号
video_path=r"E:\MyProjects\sampletest\1.avi"    #视频路径
im_dir=r"E:\MyProjects\sampletest\1"    #图片目录
frames_info_path=r"E:\MyProjects\sampletest\1\objs_frame_info.txt" #存放帧信息txt

# 1. 读取目标帧信息
objs_frame_info= pd.read_csv(frames_info_path,sep=' ', index_col='object_num')
objs_num=objs_frame_info.shape[0]  #行,目标个数

for obj_num in range(1, objs_num + 1):
    obj_dir=os.path.join(im_dir,str(video_name)+"_"+str(obj_num),'img')
    draw_init_pos(obj_dir)
    obj_groundtruth=os.path.join(im_dir,str(video_name)+"_"+str(obj_num),'groundtruth_rect.txt')
    f = open(obj_groundtruth,'w')
    f.write('{0} {1} {2} {3}'.format(x_lt,y_lt,w,h))
    f.close()
```
### 4. 制作效果视频
根据图片和目标坐标，最后制作成效果视频

```python
import cv2
import pandas as pd
import os
import shutil

video_name=1    #视频编号
video_path=r"E:\MyProjects\sampletest\1.avi"    #视频路径
im_dir=r"E:\MyProjects\sampletest\1"    #图片目录
frames_info_path=r"E:\MyProjects\sampletest\1\objs_frame_info.txt" #存放帧信息txt
video_info_path=r"E:\MyProjects\sampletest\video_info.txt"

#  读取该视频的信息，存储到video_info，包括：
#  video_num:   第几个视频
#  object_num:  第几个目标
#  frame_rate:  合成该视频的帧率
#  size_w： 视频的宽
#  size_h： 视频的高
video_info=pd.read_csv(video_info_path,index_col='video_num')
fps = video_info.loc[video_name,"frame_rate"]  # 视频每秒24帧
size = (video_info.loc[video_name,"size_w"], video_info.loc[video_name,"size_h"])  # 需要转为视频的图片的尺寸
video = cv2.VideoWriter(str(video_name)+".avi", cv2.VideoWriter_fourcc('X', 'V', 'I', 'D'), fps, size)

# 1. 读取目标帧信息
objs_frame_info= pd.read_csv(frames_info_path,sep=' ', index_col='object_num')
objs_num=objs_frame_info.shape[0]  #行,目标个数

im_list = []  # 新建空链表
for item in os.listdir(im_dir):
    if (item.endswith('.jpg')):  # 如果是.jpg文件，则放到filelist
           im_list.append(item)
im_list.sort(key=lambda x:int(x[:-4]))

for obj_num in range(1, objs_num + 1):
    pos_path=os.path.join(im_dir,str(video_name) + '_' + str(obj_num),"pos_result.txt")
    locals()['pos_result'+str(obj_num)]=pd.read_csv(pos_path,sep=' ', names=['x','y','w','h'])

for im_fullname in im_list:
    im_path = os.path.join(im_dir, im_fullname)  # 获取每张图片路径
    im = cv2.imread(im_path)  # 读取图片

    (im_name, extension) = os.path.splitext(im_fullname)
    cur_frame = int(im_name)

    for obj_num in range(1, objs_num + 1):
        if cur_frame >= objs_frame_info.loc[obj_num, "start_frame"] and cur_frame <= objs_frame_info.loc[
            obj_num, "end_frame"]:
            pos_reslut=locals()['pos_result' + str(obj_num)]
            pos_index=cur_frame-objs_frame_info.loc[obj_num, "start_frame"]
            x_lt = int(pos_reslut.loc[pos_index, "x"])
            y_lt = int(pos_reslut.loc[pos_index, "y"])
            x_rb = int(pos_reslut.loc[pos_index, "x"] + pos_reslut.loc[pos_index, "w"])
            y_rb = int(pos_reslut.loc[pos_index, "y"] + pos_reslut.loc[pos_index, "h"])

            cv2.rectangle(im, (x_lt, y_lt), (x_rb, y_rb), (0, 0, 255), 1)
    video.write(im)
video.release()
```

### 5.将ECO跟踪跑得的每个目标的结果坐标组合到一个视频里
```python
import cv2
import numpy as np
import pandas as pd
import os

#吊舱的测试视频有11个，这里选择是第几个视频，保存为num
video_num=4
num=video_num

#  读取该视频的信息，存储到video_info，包括：
#  video_num:   第几个视频
#  object_num:  第几个目标
#  frame_rate:  合成该视频的帧率
#  size_w： 视频的宽
#  size_h： 视频的高
video_info=pd.read_csv(r"E:\work\zmvision\12suo\picsamples\video_info.txt",index_col='video_num')

#   获得该视频的目标的个数，存放在sub_num
sub_num=video_info.loc[video_num,"object_num"]  #第n个总共有7个目标

#  主目录：存放该视频所有图片的目录，根据这些图片合成视频
main_dir=os.path.join(r'E:\work\zmvision\12suo\picsamples',str(num))
pic_dir=main_dir

#  存放每个目标的起始帧和结束帧的文本文件
#  将这些信息保存到info_stendframes
info_stendframes_path=os.path.join(pic_dir,'info_stendframes.txt')
info_stendframes=pd.read_csv(info_stendframes_path, sep=' |\t',index_col='object_num')
#   print(info_stendframes)
#   print(info_stendframes.loc[34,"start_frame"])

#   将主目录下所有以".jpg"的文件加入到filelist，排除其他文本文件和文件夹
filelist=[]     #  新建空链表
file_list = os.listdir(pic_dir)     #  首先获取所有文件
for i in file_list:
    if (i.endswith('.jpg')):        #  如果是.jpg文件，则放到filelist
        filelist.append(i)

#  每个目标都有很多坐标，将每个目标的坐标文件存到相应的data里面
#  使用p来记录已经到该目标的哪一帧了
for i in range(1,sub_num+1):
    loc_dir=os.path.join(pic_dir,str(num)+'_'+str(i),str(num)+'_'+str(i)+'.txt')
    locals()['data'+str(i)]=pd.read_csv(loc_dir, sep='\t', names=['y', 'x', 'h', 'w'])
    locals()['p'+str(i)]=-1

# 合成视频设置,包括帧率，尺寸，编码格式
fps = video_info.loc[video_num,"frame_rate"]  # 视频每秒24帧
size = (video_info.loc[video_num,"size_w"], video_info.loc[video_num,"size_h"])  # 需要转为视频的图片的尺寸
video = cv2.VideoWriter(str(num)+".avi", cv2.VideoWriter_fourcc('X', 'V', 'I', 'D'), fps, size)

i = 1
for item in filelist:   # 遍历所有图片
    pic_path=os.path.join(pic_dir, item)    #  获取每张图片路径
    img = cv2.imread(pic_path)          # 读取图片

    for num_object in range(1, sub_num+1):  #  遍历每个目标
        # 查看现在遍历到的原图是否有该目标。如果有，则将该目标的坐标画框合成到原图里
        if i >= info_stendframes.loc[num_object, "start_frame"] and i < info_stendframes.loc[num_object, "end_frame"]:
            locals()['p' + str(num_object)]=locals()['p' + str(num_object)]+1
            p=locals()['p' + str(num_object)]
            data=locals()['data' + str(num_object)]
            x_lt = int(data.loc[p, "x"] - data.loc[p, "w"] / 2)
            y_lt = int(data.loc[p, "y"] - data.loc[p, "h"] / 2)
            x_rb = int(data.loc[p, "x"] + data.loc[p, "w"] / 2)
            y_rb = int(data.loc[p, "y"] + data.loc[p, "h"] / 2)
            cv2.rectangle(img, (x_lt, y_lt), (x_rb, y_rb), (0, 255, 0), 2)
            print("x  :"+str(data.loc[p, "x"]))
            print("y  :" + str(data.loc[p, "y"]))
            font = cv2.FONT_HERSHEY_COMPLEX
            text = str(num_object)
            cv2.putText(img, text, (x_lt, y_lt), font, 0.7, (0, 0, 255), 1)

    '''
    cv2.imshow("aa", img)
    print(item)
    print(info_stendframes.loc[num_object, "start_frame"])
    while cv2.waitKey(0):
       break
    '''
    video.write(img)
    i = i + 1
    print(i)

video.release()
cv2.destroyAllWindows()
```