# 1.11 Python技能

## 1.11.0 常用的python代码

### 1. Python中以绝对路径或者相对路径导入文件的方法
#### 1.1 路径了解
../ 表示当前文件所在的目录的上一级目录
./ 表示当前文件所在的目录(可以省略)
/ 表示当前站点的根目录(域名映射的硬盘目录)
```python
import os
path1=os.path.abspath('.')   # 表示当前所处的文件夹的绝对路径
path2=os.path.abspath('..')  # 表示当前所处的文件夹上一级文件夹的绝对路径
print(path2)
```

可以在python 环境下使用：
```python 
sys.path.append(‘你的模块的名称’)。
sys.path.insert(0,’模块的名称’)
```
添加相关的路径，但在退出python环境后自己添加的路径就会自动消失！

代码中的实现如下：
```python
import sys
sys.path.append('C:\Users\Administrator\Desktop\ExperimentAss\gcForest-master')
```
#### 1.2 了解一下 python 在不同层级目录import 模块的方法

有一个文件夹/home/a, 里面有个模块叫b.py, 我怎么把他import到程序里？

**方法一：**
```python
import sys;
sys.path.append(“/home/a/”)
import b
```

**方法二：**
在目录里面增加__init__.py文件，里面可以写import时执行的代码，当然也可以留空就可以.
import home.a.b

**方法三：**
from home.a.b import *
  前提 home、a中都包括__init__.py 即：要导入的文件的当前目录和父目录都要有init.py文件

---

Python包含子目录中的模块方法比较简单，关键是能够在sys.path里面找到通向模块文件的路径。
下面将具体介绍几种常用情况:

（1）主程序与模块程序在同一目录下:

如下面程序结构:
– src
  |– mod1.py
  |– test1.py

  若在程序test1.py中导入模块mod1, 则直接使用import mod1或from mod1 import *;

（2）主程序所在目录是模块所在目录的父(或祖辈)目录
如下面程序结构:
– src
|– mod1.py
|– mod2
  | – mod2.py
– test1.py

  若在程序test1.py中导入模块mod2, 需要在mod2文件夹中建立空文件__init__.py文件(也可以在该文件中自定义输出模块接口); 然后使用 from mod2.mod2 import * 或import mod2.mod2.

（3）主程序导入上层目录中模块或其他目录(平级)下的模块
如下面程序结构:
– src
  |– mod1.py
  |– mod2
   |– mod2.py
  |– sub
    | – test2.py
  – test1.py
  若在程序test2.py中导入模块mod1.py和mod2.py。首先需要在mod2下建立__init__.py文件(同(2))，src下不必建立该文件。然后调用方式如下:
  下面程序执行方式均在程序文件所在目录下执行，如test2.py是在cd sub;之后执行python test2.py
而test1.py是在cd src;之后执行python test1.py; 不保证在src目录下执行python sub/test2.py成功。
import sys
sys.path.append(“..”)
import mod1
import mod2.mod2

（4）从(3)可以看出，导入模块关键是能够根据sys.path环境变量的值，找到具体模块的路径。这里仅介绍上面三种简单情况。

#### 总结：

  通过总结可以发现，当你要导入的文件在和你的当前文件在同一个目录时，你直接导入这个文件名就好了。

  当你要导入的文件或者目录不和你的当前文件同目录时，你需要跳到这个你要导入文件的父级目录，然后一级一级的用点号连接走过的目录或者文件，然后就可以了 至于要怎么跳到这个这个父级目录。比较通用的就是，将父级目录加入系统路径，然后用点号一级一级的寻找，直到到达你要导入的模块。

## 1.11.1 相关系统函数

### 1. 常用
`import os` 导入os包
`import shutil` 导入shutil模块，高级文件操作，复制，粘贴，移动，删除
`os.path.join()` 合并路径
`os.rename()` 重命名文件
`os.listdir()` 列出目录下文件名
`os.path.exists(path)` 判断一个目录是否存在
`os.makedirs(path)` 多层创建目录
`os.mkdir(path)` 创建目录

### 2. glob函数
glob中支持的通配符有三种：
‘*’ 匹配0个或多个字符
‘?’ 仅匹配一个字符
‘[]’ 匹配指定范围内的字符，如[0-9]匹配数字

在python中，glob模块是用来查找匹配的文件的
在查找的条件中，需要用到Unix shell中的匹配规则：
  \*    :   匹配所所有
  ?    :   匹配一个字符
  *.*  :   匹配如：[hello.txt,cat.xls,xxx234s.doc]
  ?.*  :   匹配如：[1.txt,h.py]
  ?.gif:   匹配如：[x.gif,2.gif]
  如果没有匹配的，glob.glob(path)将返回一个空的list:[]

#### Python 之 glob读取路径下所有文件夹或文件方法
**1. glob示例一**
```python
import glob  
def get_all(): #获取目录[F:\\wfpdm\\My_Proc_Data_ZXTZ]下面所有的文件 
    return glob.glob('F:\\wfpdm\\My_Proc_Data_ZXTZ\\*.*') 

def get_my_file():  #获取目录[F:\\wfpdm\\My_Proc_Data_ZXTZ]下面文件名为4个字符的文件
    return glob.glob('F:\\wfpdm\\My_Proc_Data_ZXTZ\\????.txt')

def get_batch_file():  #获取目录[F:\\wfpdm\\My_Proc_Data_ZXTZ]下面扩展名为\'.txt\'的文件 
    return glob.glob('F:\\wfpdm\\My_Proc_Data_ZXTZ\\*.txt') 

def main():  
    print('获取目录[F:\\wfpdm\\My_Proc_Data_ZXTZ]下面所有的文件：')
    tem_files = get_all()  
    print(tem_files)  
    
    print('获取目录[F:\\wfpdm\\My_Proc_Data_ZXTZ]下面文件名为4个字符的文件：')  
    tem_files = get_my_file()  
    print(tem_files)  
    
    print('获取目录[F:\\wfpdm\\My_Proc_Data_ZXTZ]下面扩展名为\'.txt\'的文件：')  
    tem_files = get_batch_file()  
    print(tem_files)  
    
if __name__ == '__main__':  
    main()  
```
**2. glob示例二**
```python
from os.path import exists, isdir, basename, join, splitext
from glob import glob
EXTENSIONS = ['.zxtz']
def get_categories(datasetpath):
    '''得到所有分类，文件夹名称'''
    cat_paths = [files for files in glob(datasetpath + "/*") if isdir(files)] # datasetpath下所有路径
    cat_paths.sort()
    cats = [basename(cat_path) for cat_path in cat_paths]
    return cats

def get_files(path, extensions=EXTENSIONS):
    '''返回分类路径path下的所有视频文件名,list'''
    all_files = []
    all_files.extend([join(path, basename(fname)) for fname in glob(path + "/*") if splitext(fname)[1] in extensions])
    return all_files
```

### 3.shutil函数

#### 3.1 文件夹和文件复制

**`shutil.copyfileobj(fsrc, fdst[, length])`**

复制类文件(file-like)对象 `fsrc` 的内容到类文件对象 `fdst`。 可选**整数参数** `length`， 指定缓冲区大小。具体而言， `length` 的值为负数，复制操作不会将源数据分块进行复制。 默认的，为了避免不可控制的内存消耗，数据会被分块存入chunk中。 **注意：** 如果 `fsrc` 对象的当前文件位置不为 0 ，则只有从当前文件位置到文件末位的内容会被复制。

**`shutil.copyfile(src, dst)`**

复制文件 `src` 的内容（不包含元素据）到文件 `dst` 中。 `dst` 必须为一个完整的目标文件。 如果要将文件复制目标文件夹中，查看 `shutil.copy()` 。 `src` 和 `dst` 不能为同一个文件，否则会[报错](https://tangx.in/2016/11/24/python-libaray-shutil-shell-command-for-python/#shutil.Error)。 目标文件位置必须为可写状态，否则会触发 [IOError](https://docs.python.org/2/library/exceptions.html#exceptions.IOError)。 如果 `dst` 已经存在，则会被覆盖。 特别的， 字符设备、块设备和管道不能使用此方法复制。 使用字符串指定`src` 和 `dst` 路径。

**`shutil.copymode(src, dst)`**

复制 `src` 的文件**权限位**到 `dst` 。 文件的内容、属主和用户组不会受影响。 使用字符串指定`src` 和 `dst` 路径。

**`shutil.copystat(src, dst)`**

复制文件 `src` 的文件**权限位**、**最后访问 access 时间**、**最后修改 modification 时间**和**标识 flags **到 `dst`。文件的内容、属主和用户组不会受影响。 使用字符串指定`src` 和 `dst` 路径。

**`shutil.copy(src, dst)`**

复制文件 `src` 到 `dst` 文件或文件夹中。 如果 `dst` 是文件夹， 则会在文件夹中创建或覆盖一个文件，且该文件与 `src` 的文件名相同。 文件权限位会被复制。使用字符串指定`src` 和 `dst` 路径。

**`shutil.copy2(src, dst)`**

与 `shutil.copy()` 类似，另外会同时复制文件的元数据。 实际上，该方法是 `shutil.copy()` 和 `shutil.copystat()` 组合。该方法相当于 Unix 命令的 ` cp -p `。

**`shutil.ignore_patterns(*patterns)`**

该工厂函数创建了一个可以被调用的函数， 该函数可以用于 `shutil.copytree()` 的 ** ignore 参数**的值， 以跳过正确匹配的文件和文件夹。 更多参考下面离职。

**`shutil.copytree(src, dst, symlinks=False, ignore=None)`**

递归复制整个 `src` 文件夹。 目标文件夹名为 `dst`，不能已经存在；方法会自动创建 `dst` 根文件夹。 文件夹权限和时间通过 `shutil.copystat()` 复制， 单独的文件通过 `shutil.copy2()` 复制。 如果 ` symlinks ` 为真， 源文件夹中的符号链接将会被保留，但是原链接的元数据**不会**被复制。如果值为假或被省略，则链接文件指向文件的内容和元数据复制到新文件夹树中。 如果指定了 `ignore`， 那么他必须是调用队列(callable)，且作为 `shutil.copytree()` 的参数。参数包括文件夹本机及并通过 `os.listdir()`返回文件夹包含的内容。由于 `shutil.copytree()` 递归复制，因此 `ignore` 会在复制每个子文件夹的时候被调用。 callable必须返回一个由当前文件夹下的文件夹和文件所组成的队列（i.e. a subset of the items in the second argument)； 这些文件夹和文件在复制过程中会被忽略。可以使用 `shutil.ignore_patterns()` 创建callable。

如果发生意外， `shutil.Error()` 返回错误原因。

该源码应该被当作一个示例而不是最终的工具。

> Changed in version 2.3: Error is raised if any exceptions occur during copying, rather than printing a message. Changed in version 2.5: Create intermediate directories needed to create dst, rather than raising an error. Copy permissions and times of directories using copystat(). Changed in version 2.6: Added the ignore argument to be able to influence what is being copied.

#### 3.2移动和删除

**`shutil.rmtree(path[, ignore_errors[, onerror]])`**

删除整个目录树； `path` 必须指向一个文件夹，但不能是一个指向文件夹的符号链接。 如果 ` ignore_errors ` 值为真， 则删除失败时的信息将会被忽略。如果值为假或省略，那么这些错误将通过 `onerror` 指定的 handler 进行处理； 如果 `onerror` 被省略，则会 raise 一个异常。

如果指定了 `onerror`，则必须是包含三个参数： **function, path 和 excinfo**的 callable 。 第一个参数 ` function ` ， 该函数用于 raise 异常；该函数可以是 `os.path.islink(), os.listdir(), os.remove(), os.rmdir()`。 第二个参数 `path` 为传递给第一个参数的路径。 第三个参数 `excinfo` 为 `sys.exc_info()`返回的异常信息。 通过 `onerror` raise 的异常不会被捕捉。

> Changed in version 2.6: Explicitly check for path being a symbolic link and raise [OSError](https://docs.python.org/2/library/exceptions.html#exceptions.OSError) in that case.

**`shutil.move(src, dst)`**

将一个文件或文件夹从 `src` 移动到 `dst` 如果 `dst` 已存在且为文件夹，则 `src` 将会被移动到 `dst`内。 如果如 `dst` 存在但不是一个文件夹， 取决于 `os.rename()` 的语义，`dst` 可能会被覆盖。 如果 `dst` 与 `src` 在相同的文件系统下， 则使用 `os.rename()` 。 否认则，将使用 `shutil.copy2()` 复制 `src`到 `dst` 并删除。

**`shutil.Error `**

该异常汇集文件操作时 raise 的异常。 例如 `shutil.copytree()`， the exception argument is a list of 3-tuples (srcname, dstname, exception).

## 1.11.2 文件和文件夹操作
### 1.使用python创建n个空文件夹
```python
import os

# 函数：在dir路径下创建n个文件夹
def mk_dir(dir,n):
    for i in range(1,n+1):
        dir_path=os.path.join(dir,str(i))
        if not os.path.exists(dir_path):
            os.makedirs(dir_path)

im_dir=r"E:\MyProjects\sampletest\1"
mk_dir(im_dir,5)
```

### 2. 使用python复制文件
**1. 将目录中命名为9148-9429的文件复制到另一个文件夹中**

```python
import cv2
import numpy as np
import pandas as pd
import os
import shutil

src_path=r'E:\12suo\11'
dst_path=r'E:\12suo\11_32'

i=1
for pic_filename in os.listdir(src_path):
    if i>= 9148 and i<=9429: #复制9148-9429的图片
        old_picpath=os.path.join(src_path, pic_filename)
        new_picpath = os.path.join(dst_path, pic_filename)
        shutil.copy(old_picpath,new_picpath)
    i = i + 1
```

**2. 复制1-12个文件夹的.jpg图片到另外的相应的路径下**

```python
import cv2
import numpy as np
import pandas as pd
import os
import shutil
src_main_dir=r"E:\work\zmvision\12suo\picsamples"
dst_main_dir=r"E:\MyProjects\algorithm\stc-vs2015\samples\picsamples\12suo_zhenghe"
for video_num in range(1,12):
    src_pic_dir=os.path.join(src_main_dir,str(video_num))
    dst_pic_dir = os.path.join(dst_main_dir, str(video_num))
    piclist = []  # 新建空链表
    file_list = os.listdir(src_pic_dir)  # 首先获取所有文件
    for item in file_list:
        if (item.endswith('.jpg')):  # 如果是.jpg文件，则放到filelist
            old_picpath = os.path.join(src_pic_dir, item)
            new_picpath = os.path.join(dst_pic_dir, item)
            shutil.copy(old_picpath, new_picpath)
```
### 3. 使用python对文件进行重命名
**1. 目录中的图片的命令并不是以0001.jpg开始，而是以0072.jpg开始。将所有图片重命名，第一张以0001.jpg开始命名**

```python
import os
# 函数：对file_dir目录下的文件进行重命名
def replace_filename(file_dir):
    i=int(min(os.listdir(file_dir)).split('.')[0])-1
    for old_filename in os.listdir(file_dir):
        new_filename='{:0>4s}'.format(str(int(old_filename.split('.')[0])-i))+'.jpg'
        oldfilepath=os.path.join(filedir,old_filename)
        newfilepath=os.path.join(filedir,new_filename)
        os.rename(oldfilepath,newfilepath)
        
file_dir=r'D:\Program Files\ffmpeg-20180825-844ff49-win64-static\ffmpeg-20180825-844ff49-win64-static\bin\第1个视频\第二段'
replace_filename(file_dir)
```

### 4.os文件路径、文件名、后缀分割
```python
import os
file_path = "E:/tt/abc.py"
filepath,fullflname = os.path.split(file_path)
fname,ext = os.path.splitext(fullflname)
```
运行结果：
filepath为文件的目录,即E:/tt 
fullflname为文件名的全名，即abc.py
fname为文件的名字,即abc 
ext为文件的扩展名,即.py

basename用法是去掉目录路径，单独返回文件名abc.py
dirname：去掉文件名，单独返回目录路径E:/tt

### 5.打印文件名
```python
from PIL import Image
import matplotlib.pyplot as plt

img= Image.open(r'Z:\bak\zonghe\girl_boy\1005.png')
img2=Image.open(r'Z:\bak\test4\mzj_output4\1005.png')
plt.imshow(img)
plt.show()
plt.imshow(img2)
plt.show()

img_dir1=r"Z:\bak\zonghe\girl_boy"
imgFullnames1=glob(join(img_dir1,'*'))
imgFullnames1.sort()

i=1
for item in imgFullnames1:
    filepath,fullflname = os.path.split(item)
    fname,ext = os.path.splitext(fullflname)
    #print(int(fname))
    while i<int(fname):
        print(i)
        i=i+1
    i=i+1
```
### 6. 跟踪结果文件复制
```python
def cp_result(src_dir,dst_dir):
    resultfile=glob.glob('/root/deepTracking/tracking_datasets/612_test/*/*/'+src_dir+'/pos_result.txt')
    dst_path='/root/wu/trackresult/'+dst_dir
    if os.path.exists(dst_path):
        shutil.rmtree(dst_path)
        os.mkdir(dst_path)
    else:
        os.mkdir(dst_path)
    for item in resultfile:
        file_name=item.split('/')[6]
        dst_file=os.path.join(dst_path,file_name+'.txt')
        shutil.copy(item,dst_file)
```
## 1.11.3 Python 对图片和视频的操作
### 1.视频切割成图像
**1.将dir1目录下视频 切成 图片存放在dir2目录下，并以"%04d.jpg"形式储存**
```python
import cv2
import numpy as np
import os


#  读取视频
capture = cv2.VideoCapture(r'dir1\11.avi')

#  存储图片的文件夹
file_dir=r'dir2\11'

if capture.isOpened():
    i=0
    while True:
        ret, prev = capture.read()
        if ret == True:        #  如果读取到图片
            i=i+1
            # 将命名改为"%04d.jpg"
            picfilename = '{:0>4s}'.format(str(i)) + '.jpg'     
            picpath = os.path.join(file_dir, picfilename)
            #cv2.imshow('video', prev)
            cv2.imwrite(picpath,prev)        #  写图片
        else:
            break
        if cv2.waitKey(20) == 27:
            break
cv2.destroyAllWindows()
```

**2.将视频切割成图片**

video_path:视频路径
im_dir: 存储图片目录
im_type="jpg"：存储图片类型，默认.jpg
im_name_mode=0：文件命名格式，默认1.jpg

```python
import cv2
import numpy as np
import os

def video2im(video_path,im_dir,im_type="jpg",im_name_mode=0):
    cap=cv2.VideoCapture(video_path)
    i=1
    while True:
        ret,im=cap.read()
        if ret==True:
            if(im_name_mode=="0"):
                im_name=str(i)+"."+im_type
            #else:
            #im_name='{:0>{1}s}'.format(str(i),im_name_mode)+"."+im_type
            im_name = '{0:0>{1}}'.format(str(i),im_name_mode) + "." + im_type
            im_path=os.path.join(im_dir,im_name)
            cv2.imwrite(im_path,im)
        else:
            break
        i=i+1

video_path=r"E:\MyProjects\sampletest\1.avi"
im_dir=r"E:\MyProjects\sampletest\1"

video2im(video_path,im_dir)
```

### 2.跟踪效果视频生成
#### 2.1一个框
```python
import cv2
import numpy as np
import os
import pandas as pd
pic_dir=r'F:\BaiduNetdiskDownload\KCF\data\aa'
filelist=[]     #  新建空链表
file_list = os.listdir(pic_dir)     #  首先获取所有文件
for i in file_list:
    if (i.endswith('.png')):        #  如果是.jpg文件，则放到filelist
        filelist.append(i)
        
video1 = cv2.VideoWriter("bb.mp4", cv2.VideoWriter_fourcc('X', 'V', 'I', 'D'), 30, (1920,1080))
ground=pd.read_csv(r'F:\BaiduNetdiskDownload\KCF\re\1.txt',header=None)

i = 0
for item in filelist:   # 遍历所有图片
    pic_path=os.path.join(pic_dir, item)    #  获取每张图片路径
    img = cv2.imread(pic_path)    
    
    x_lt = int(ground.iloc[i][0]-42)
    y_lt = int(ground.iloc[i][1]-33)
    x_rb = int(ground.iloc[i][0]+42)
    y_rb = int(ground.iloc[i][1]+33)
    
    cv2.rectangle(img, (x_lt, y_lt), (x_rb, y_rb), (0, 255, 0), 2)
    
    video1.write(img)
    i = i + 1
    print(i)
video1.release()
```

#### 2.2两个框
```python
import os
import glob
from os.path import exists, isdir, basename, join, splitext
from glob import glob
import cv2
import numpy as np

img_dir = r'J:\fandeyingpan\OTB100\Deer\img'
save_dir = r'E:\tmp\Deer_video'
siamban_result_path = r'E:\gitee\tracker_benchmark_v1.1_1\presults\D3S\Deer.txt'
ours_result_path = r'E:\gitee\tracker_benchmark_v1.1_1\presults\deblur_v2.0\Deer.txt'
ground_truth_path = r'J:\fandeyingpan\OTB100\Deer\groundtruth_rect.txt'

siamban_results = np.loadtxt(siamban_result_path, dtype=int, delimiter=',')
ours_results = np.loadtxt(ours_result_path, dtype=int, delimiter=',')
gt_results = np.loadtxt(ground_truth_path, dtype=int, delimiter=',')

img_fullnames = glob(os.path.join(img_dir, '*.jpg'))
img_fullnames.sort()

count = 0
number = 1
for item in img_fullnames:
    img = cv2.imread(item)  # 保存
    simban_x_lt = siamban_results[count][0]  # 左上角坐标x（待确定）
    simban_y_lt = siamban_results[count][1]  # 左上角坐标y（待确定）
    simban_x_rb = siamban_results[count][0] + siamban_results[count][2]  # 右下角坐标x（待确定）
    simban_y_rb = siamban_results[count][1] + siamban_results[count][3]  # 右下角坐标y（待确定）

    ours_x_lt = ours_results[count][0]  # 左上角坐标x（待确定）
    ours_y_lt = ours_results[count][1]  # 左上角坐标y（待确定）
    ours_x_rb = ours_results[count][0] + ours_results[count][2]  # 右下角坐标x（待确定）
    ours_y_rb = ours_results[count][1] + ours_results[count][3]  # 右下角坐标y（待确定）

    gt_x_lt = gt_results[count][0]  # 左上角坐标x（待确定）
    gt_y_lt = gt_results[count][1]  # 左上角坐标y（待确定）
    gt_x_rb = gt_results[count][0] + ours_results[count][2]  # 右下角坐标x（待确定）
    gt_y_rb = gt_results[count][1] + ours_results[count][3]  # 右下角坐标y（待确定）

    cv2.rectangle(img, (simban_x_lt, simban_y_lt), (simban_x_rb, simban_y_rb), (0, 255, 0), 3)  # 颜色不确定，最好用绿色
    cv2.rectangle(img, (ours_x_lt, ours_y_lt), (ours_x_rb, ours_y_rb), (0, 0, 255), 3)  # 颜色不确定，最好用红色
    cv2.rectangle(img, (gt_x_lt, gt_y_lt), (gt_x_rb, gt_y_rb), (0, 255, 255), 3)  # 颜色不确定，最好用黄色

    # 左上角加帧数，颜色用黄色，不确定代码对不对，做参考
    font = cv2.FONT_HERSHEY_SIMPLEX
    text = '#' + str(number).zfill(4)
    print(text)
    cv2.putText(img, text, (10, 30), font, 0.7, (0, 255, 255), 2)
    save_path = os.path.join(save_dir, basename(item))
    cv2.imwrite(save_path, img)
    count = count + 1
    number = number + 1
```

### 3.对一个目录下的所有图片进行重命名
```python
import glob
import os
import numpy as np
import pandas as pd
import shutil

from os.path import exists, isdir, basename, join, splitext
from glob import glob

img_dir=r'D:\360MoveData\Users\whu\Desktop\新建文件夹 (2)'
imgFullnames=glob(join(img_dir,'*'))

i=1
for item in imgFullnames:
    name='{:0>4s}'.format(str(i))
    name1=join(img_dir,name+'.jpg')
    os.rename(item,name1)
    i=i+1
```

### 4.图片合成视频
```python
import cv2
import numpy as np
import pandas as pd
import os

video = cv2.VideoWriter("mzj6.mp4", cv2.VideoWriter_fourcc('X', 'V', 'I', 'D'), 25, (1920,1080))
img_dir1=r"G:\faceswap\girl_boy1"
imgFullnames1=glob(join(img_dir1,'*'))
imgFullnames1.sort()
for item in imgFullnames1:
    img = cv2.imread(item)
    video.write(img)
    print(item)
video.release()
```

### 5. 为视频加上声音
```python
from moviepy.editor import VideoFileClip

from moviepy.editor import VideoFileClip
fg_video_path = r"G:\faceswap\video.flv"

def from_video_get_mp3():
    video = VideoFileClip(fg_video_path)
    audio = video.audio
    name = fg_video_path.split('.', 1)[0] + ".mp3"
    audio.write_audiofile(name)
    return name


def add_mp3(video_have_zm):
    fg_video = VideoFileClip(fg_video_path)
    video = VideoFileClip(video_have_zm)
    audio = fg_video.audio
    videoclip2 = video.set_audio(audio)
    name1 = video_have_zm.split('.', 1)[0] + "_out.mp4"
    videoclip2.write_videofile(name1)


if __name__ == '__main__':
    add_mp3('mzj6.mp4')
```
## 1.11.4 pandas
### 1. 序列查找
```python
for item in b:
    if item in a:
        print(b[item])
```
### 2. 未知
```python
import pandas as pd
from pandas import Series,DataFrame

# 读取表格，打印表格基本信息
df = pd.read_csv(r'C:\Users\Mao\Desktop\jiu.csv',header=None)

df.shape()

df.head()
df.info()
type(df) #pandas.core.frame.DataFrame
df.duplicated()
df.count()

#若df.iloc[0]是一个表格
df.iloc[0].value_counts() # 对表格进行值的计数
type(df.iloc[0]) #pandas.core.series.Series
type(df.iloc[0:1]) #pandas.core.frame.DataFrame
type(df) #pandas.core.frame.DataFrame
type(df.values) #numpy.ndarray
df.values  #打印df的值
df.iloc[0:2].values #打印df两行的值
df.iloc[0:2].values.shape  #2行6列

#series
obj=pd.Series([4,7,-5,3])
obj.values  # 打印一个array
obj.index  #RangeIndex(start=0, stop=4, step=1)
obj2=pd.Series([4,7,-5,3],index=['d','b','a','c']) #指定索引
obj2>2  # 值大于2 相应索引的值变为True
obj2[obj2>2] #打印值大于2的项目

#
sdata={'Ohio':35000,'Texas':71000,'Oregon':16000,'Utah':5000}
obj3=pd.Series(sdata)
states=['California','Ohio','Oregon','Texas']
obj4=pd.Series(sdata,index=states) #obj4有一项为NaN
pd.notnull(obj4) # 打印，将NaN项打印为False
obj4.isnull() #和上面相反
obj4.name='population'
obj4.index.name='state'

#
data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'],
        'year': [2000, 2001, 2002, 2001, 2002, 2003],
        'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}
frame = pd.DataFrame(data)
pd.DataFrame(data,columns=['year','state'])
frame.columns #Index(['state', 'year', 'pop'], dtype='object')
frame2 = pd.DataFrame(data, columns=['year', 'state', 'pop', 'debt'],index=['one', 'two', 'three', 'four','five', 'six'])
frame2.columns  #Index(['year', 'state', 'pop', 'debt'], dtype='object')
frame2['state']
frame2.loc['one']
frame2['debt']=16.5

#
val=pd.Series([-1.2,-1.5,-1.7],index=['two','four','five'])
frame2['debt']=val
frame2['eastern']=frame2.state=='Ohio'
del frame2['eastern']
frame2.columns #Index(['year', 'state', 'pop', 'debt'], dtype='object')

pop = {'Nevada': {2001: 2.4, 2002: 2.9},'Ohio': {2000: 1.5, 2001: 1.7, 2002: 3.6}}

frame3=pd.DataFrame(pop)
frame3.T
frame3['Ohio'][:-1]

frame3.index.name='year'
frame3.columns.name='state'
frame3.values
obj=pd.Series(range(3),index=['a','b','c'])
index=obj.index  #Index(['a', 'b', 'c'], dtype='object')
index[1:] #Index(['b', 'c'], dtype='object')

#
import numpy as np
labels=pd.Index(np.arange(3))
labels #Int64Index([0, 1, 2], dtype='int64')
obj2=pd.Series([1.5,-2.5,0],index=labels)
obj2.index is labels
frame3.columns
'Ohio' in frame3.columns
data=pd.DataFrame(np.random.randint(0,11,size=100).reshape(10,10))
data.apply(pd.value_counts)

df = pd.DataFrame({'BoolCol': [1, 2, 3, 3, 4],'attr': [22, 33, 22, 44, 66]},index=[10,20,30,40,50])
a = df[(df.BoolCol==3)&(df.attr==22)].index.tolist()
df.columns #Index(['BoolCol', 'attr'], dtype='object')
df.values==22
df[df.values==22]

#
names=['0','A','B','C','D','E','F']
data=pd.read_csv(r'C:\Users\Mao\Desktop\jiu1.csv',names=names,index_col='0')
type(data.loc[1,'A']) #numpy.float64
data.apply(pd.value_counts)
data1=pd.read_csv(r'C:\Users\Mao\Desktop\jiu.csv',header=None)
data1.apply(pd.value_counts)
test1=data1.apply(pd.value_counts).sum(axis=1).astype(np.int)
test1[test1.values > 1]
```
## 1.11.5  使用python整理OTB100
### 1.获取一个路径下所有的文件夹
```python
from os.path import exists, isdir, basename, join, splitext
from glob import glob

def get_dirs(path,fullname=True):
    all_dirs=[files for files in glob(path+'/*') if isdir(files)]
    all_dirs.sort()
    if fullname ==True:
        return all_dirs
    else:
        all_dirnames= [basename(dir_) for dir_ in all_dirs]
        return all_dirnames
        
 otbSeqDirFullname=get_dirs(path,True) #返回完整路径 
 otbSeqDirBasename=get_dirs(path,False) #只返回名称
```

### 2.获取otb每个序列图片个数
```python
for item in otbSeqDirFullname:
    pics=glob(join(item,'img\*.jpg'))
    print(basename(item),":",len(pics))
```

### 3.指定序列以小写字母排序
```python 
def case_insensitive_sort(liststring):
    listtemp = [(x.lower(),x) for x in liststring]
    listtemp.sort()
    return [x[1] for x in listtemp]
```

**otb100中可能出现大小写问题的序列:**
>basketball Basketball, bolt Bolt, boy Boy, car4 Car4, carDark CarDark, carScale CarScale, coke Coke, couple Couple, crossing Crossing, david David, david2 David2, david3 David3, deer Deer, dog1 Dog1, doll Doll, dudek Dudek, faceocc1 FaceOcc1, faceocc2 FaceOcc2, fish Fish, fleetFace FleetFace, football Football, football1 Football1, freeman1 Freeman1, freeman3 Freeman3, freeman4 Freeman4, girl Girl, Human4.2 Human4-2, ironman Ironman, jogging-1 Jogging-1, jogging-2 Jogging-2, jumping Jumping, lemming Lemming, liquor Liquor, matrix Matrix, mhyang Mhyang, motorRolling MotorRolling, mountainBike MountainBike, shaking Shaking, singer1 Singer1, singer2 Singer2, skating1 Skating1, Skating2.1 Skating2-1, Skating2.2 Skating2-2, skiing Skiing, soccer Soccer, subway Subway, suv Suv, sylvester Sylvester, tiger1 Tiger1, tiger2 Tiger2, trellis Trellis, walking Walking, walking2 Walking2, woman Woman
>

**sed替换大小写**
`sed -i 's#basketball#Basketball#g' c.txt`
`sed -i 's#F:\\Workplace\\matlab\\Datasets\\dataset-tb100#H:\\fandeyingpan\\OTB100#g' c.txt `
`sed -i 's#basketball#Basketball#g' c.txt`


### 4.使用otb制作lasot时改图片名
```python
import glob
import os
import numpy as np
import pandas as pd
import shutil
img_dir='/root/deepTracking/tracking_datasets/lasot/LaSOT_otb/otbasket/otbasket-2/img'
imgFullnames=glob(join(img_dir,'*'))
for item in imgFullnames:
    a=item.split('/')[-1]
    b="0000"+a
    oldfilepath=join(img_dir,a)
    newfilepath=join(img_dir,b)
    os.rename(oldfilepath,newfilepath)
```

### 5.在使用otb仿制lasot时使用python制作软链接
```python
files=glob.glob('/root/deepTracking/tracking_datasets/lasot/LaSOTBenchmark/*/*')
for item in files:
    file_name=item.split('/')[-1]
    print('ln','-s',item,'/root/siamban/testing_dataset/LaSOT/'+file_name)
```

### 6.复制结果

**将跟踪得到的结果路径复制一份**

```python
import glob
import os
import numpy as np
import pandas as pd
import shutil
def cp_result(src_dir,dst_dir):
    resultfile=glob.glob('/root/deepTracking/tracking_datasets/612_test/*/*/'+src_dir+'/pos_result.txt')
    dst_path='/root/wu/trackresult/'+dst_dir
    if os.path.exists(dst_path):
        shutil.rmtree(dst_path)  # 递归删除目录
        os.mkdir(dst_path)
    else:
        os.mkdir(dst_path)
    for item in resultfile:
        file_name=item.split('/')[6]
        dst_file=os.path.join(dst_path,file_name+'.txt')
        shutil.copy(item,dst_file)
 cp_result("siamban3_result","siamban3")
```

### 7.创建文件夹

```python
if os.path.exists(path6):
    shutil.rmtree(path6)
    os.mkdir(path6)
else:
    os.mkdir(path6)
```

### 改名
```python
import os
import glob
from os.path import exists, isdir, basename, join, splitext
from glob import glob
import numpy as np

files=glob(r'D:\360MoveData\Users\whu\Desktop\DiMP_uav\*.txt')
len(files)  #123
files[0]  #'D:\\360MoveData\\Users\\whu\\Desktop\\DiMP_uav\\uav_bike1.txt'

for item in files:
    filepath,fullflname = os.path.split(item)
    fname,ext = os.path.splitext(fullflname)
    fname1=fname[4:]+'.txt'
    newname=os.path.join(filepath,fname1)
    os.rename(item,newname)
    print(item,newname)
```

```python
files=glob(r'D:\360MoveData\Users\whu\Desktop\SiamRPNpp\SiamRPN++-UAV123\SiamRPN++-UAV123\*')
files[0] #D:\\360MoveData\\Users\\whu\\Desktop\\SiamRPNpp\\SiamRPN++-UAV123\\SiamRPN++-UAV123\\bike1_SiamRPN++.mat

for item in files:
    filepath,fullflname = os.path.split(item)
    fname,ext = os.path.splitext(fullflname)
    fname1=fname[:-10]+'.mat'
    newname=os.path.join(filepath,fname1)
    print(newname)
    os.rename(item,newname)
    #print(fname,fname1)
```
```python
from os.path import exists, isdir, basename, join, splitext
from glob import glob

def get_dirs(path,fullname=True):
    all_dirs=[files for files in glob(path+'\*')]
  #  print(all_dirs)
    all_dirs.sort()
    if fullname ==True:
        return all_dirs
    else:
        all_dirnames= [basename(dir_) for dir_ in all_dirs]
        return all_dirnames
        
main_dir_atom=r'E:\MyProjects\workspace\JupyterNotebook\otb100\atom'
#print(main_dir_atom)
atom_seqnames=get_dirs(main_dir_atom,False)

def case_insensitive_sort(liststring):
    listtemp = [(x.lower(),x) for x in liststring]
    listtemp.sort()
 
    return [x[1] for x in listtemp]
atom_seqnames1=[s.lower() for s in atom_seqnames]


count=0
tmp_cot=[]
C_RPN=get_dirs('otb100/TADT',False)
#print(C_RPN)
for item in C_RPN:
    if item.lower() in atom_seqnames1:
        tmp_cot.append(item)
        src_file='otb100/ECO/'+item
        dst='otb100/ECO-1'
        print(item)
        shutil.copy(src_file,dst)
        count=count+1
print(count)
print(list(set(atom_seqnames1).difference(set([s.lower() for s in tmp_cot]))))
siampp=[files for files in glob('otb100/SiamRPNpp'+'\*')]
for item in siampp:
    a=basename(item)
    b=a.replace('+','p')
    dst_file=os.path.join('otb100/SiamRPNpp-1',b)
    print(dst_file)
    shutil.copyfile(item,dst_file)
    #print(b)
mask_dirs=[files for files in glob('otb100\mask'+'\*')]
mask_files= [basename(dir_) for dir_ in mask_dirs]

mask_files1=[]
for item in mask_files:
    a=item.split('_')[0]
    mask_files1.append(a)
mask_files2=[s.lower() for s in mask_files1]



count=0
tmp_cot=[]
C_RPN=get_dirs('otb100/SiamRPNpp',False)
C_RPN=case_insensitive_sort(C_RPN)
#print(C_RPN)
for item in C_RPN:
    if item.split('_')[0].lower() in mask_files2:
    #if item.split('_')[0].lower() == mask_files[count].split('_')[0].lower():
        
        
    
    #if item.lower() in atom_seqnames1:
        tmp_cot.append(item)
        #b=item.replace(item.split('_')[0],mask_files[count].split('_')[0])
        
        #src_file='otb100/ECO/'+item
        #dst='otb100/ECO-1'
        print(item)
       # print(b)
        #shutil.copy(src_file,dst)
    #else:
    #    print(count,item,mask_files1[count])
        count=count+1
print(count)

print(list(set(mask_files2).difference(set([s.split('_')[0].lower() for s in tmp_cot]))))
mask_files1=case_insensitive_sort(mask_files1)
mask_files=case_insensitive_sort(mask_files)
```

## 1.11.6 Python 写的小工具

### 1. 使用python将vtt字幕转换为srt字幕
```python
#coding:utf-8
import os
import sys

# 将dir下所有file_extension（vtt）扩展名的文件返回
def get_file_name(dir, file_extension):
    f_list = os.listdir(dir)  #遍历dir目录
    result_list = []
    
    for file_name in f_list:
        if os.path.splitext(file_name)[1] == file_extension:
            result_list.append(os.path.join(dir, file_name))
            print(file_name)
    return result_list

# 将vtt转为srt
def change_vtt_to_srt(file_name):
    with open(file_name, 'r',encoding="utf-8") as input_file:
        f_name_comp = os.path.splitext(file_name)[0]
        with open(f_name_comp + '.srt', 'w',encoding="utf-8") as output_file:
            for line in input_file:
                if line[:6] != 'WEBVTT':
                    output_file.write(line.replace('.', ','))


if __name__ == '__main__':
    args = sys.argv;
    print(args)

    if os.path.isdir(args[1]): # 如果输入为目录，则转换目录下的文件
        file_list = get_file_name(args[1], ".vtt")
        for file in file_list:
            change_vtt_to_srt(file)

    elif os.path.isfile(args[1]): # 如果输入为文件，则直接转换文件
        change_vtt_to_srt(args[1])
    else:
        print("arg[0] should be file name or dir");
```


### 1. glob示例一

```python
import glob  
def get_all(): #获取目录[F:\\wfpdm\\My_Proc_Data_ZXTZ]下面所有的文件 
    return glob.glob('F:\\wfpdm\\My_Proc_Data_ZXTZ\\*.*') 

def get_my_file():  #获取目录[F:\\wfpdm\\My_Proc_Data_ZXTZ]下面文件名为4个字符的文件
    return glob.glob('F:\\wfpdm\\My_Proc_Data_ZXTZ\\????.txt')

def get_batch_file():  #获取目录[F:\\wfpdm\\My_Proc_Data_ZXTZ]下面扩展名为\'.txt\'的文件 
    return glob.glob('F:\\wfpdm\\My_Proc_Data_ZXTZ\\*.txt') 

def main():  
    print('获取目录[F:\\wfpdm\\My_Proc_Data_ZXTZ]下面所有的文件：')
    tem_files = get_all()  
    print(tem_files)  
    
    print('获取目录[F:\\wfpdm\\My_Proc_Data_ZXTZ]下面文件名为4个字符的文件：')  
    tem_files = get_my_file()  
    print(tem_files)  
    
    print('获取目录[F:\\wfpdm\\My_Proc_Data_ZXTZ]下面扩展名为\'.txt\'的文件：')  
    tem_files = get_batch_file()  
    print(tem_files)  
    
if __name__ == '__main__':  
    main()  
```

### 2. glob示例二

```python
from os.path import exists, isdir, basename, join, splitext
from glob import glob
EXTENSIONS = ['.zxtz']
def get_categories(datasetpath):
    '''得到所有分类，文件夹名称'''
    cat_paths = [files for files in glob(datasetpath + "/*") if isdir(files)] # datasetpath下所有路径
    cat_paths.sort()
    cats = [basename(cat_path) for cat_path in cat_paths]
    return cats

def get_files(path, extensions=EXTENSIONS):
    '''返回分类路径path下的所有视频文件名,list'''
    all_files = []
    all_files.extend([join(path, basename(fname)) for fname in glob(path + "/*") if splitext(fname)[1] in extensions])
    return all_files
```

## 1.11.7 使用python 整理的612项目
### 1.复制功能：一个视频，知道了每个目标的起始帧和结束帧，将每个目标单独的图片放在文件夹

思路：
1.首先将视频转成图片
2.根据起始帧和结束帧复制图片

video_path:视频路径
im_dir: 存储图片目录
im_type="jpg"：存储图片类型，默认.jpg
im_name_mode=0：文件命名格式，默认1.jpg

```python
import cv2
import pandas as pd
import os
import shutil

# 视频转图片
def video2im(video_path,im_dir,im_type="jpg",im_name_mode=0):
    cap=cv2.VideoCapture(video_path)
    i=1
    while True:
        ret,im=cap.read()
        if ret==True:
            if(im_name_mode=="0"):
                im_name=str(i)+"."+im_type
            #else:
            #im_name='{:0>{1}s}'.format(str(i),im_name_mode)+"."+im_type
            im_name = '{0:0>{1}}'.format(str(i),im_name_mode) + "." + im_type
            im_path=os.path.join(im_dir,im_name)
            cv2.imwrite(im_path,im)
        else:
            break
        i=i+1
        
video_name=1    #视频编号
video_path=r"E:\MyProjects\sampletest\1.avi"    #视频路径
im_dir=r"E:\MyProjects\sampletest\1"    #图片目录
frames_info_path=r"E:\MyProjects\sampletest\1\objs_frame_info.txt" #存放帧信息txt

# 1. 视频转图片
im_list = []  # 新建空链表
for item in os.listdir(im_dir):
    if (item.endswith('.jpg')):
        im_list.append(item)
if im_list:
    print("There is exist picture")
else:
    video2im(video_path, im_dir, "jpg", 4)

# 2. 读取目标帧信息
objs_frame_info= pd.read_csv(frames_info_path,sep=' ', index_col='object_num')
objs_num=objs_frame_info.shape[0]  #行,目标个数

# 3. 创建图片目录，例：E:\MyProjects\sampletest\1\1_1\img\
for obj_num in range(1,objs_num+1):
    obj_dir=os.path.join(im_dir,str(video_name)+"_"+str(obj_num),'img')
    if not os.path.exists(obj_dir):
        os.makedirs(obj_dir)
    else:
        print("There is exist obj_dir")

# 4. 将图片的名字按顺序存放到列表，例：0001.jpg 0002.jpg
im_list = []  # 新建空链表
for item in os.listdir(im_dir):
    if (item.endswith('.jpg')):  # 如果是.jpg文件，则放到filelist
           im_list.append(item)
im_list.sort(key=lambda x:int(x[:-4]))

# 5. 根据帧信息拷贝图片到相应目录
for item in im_list:
    (im_name, extension)=os.path.splitext(item)
    cur_frame=int(im_name)
    for obj_num in range(1, objs_num + 1):
        if cur_frame >= objs_frame_info.loc[obj_num, "start_frame"] and cur_frame <= objs_frame_info.loc[obj_num, "end_frame"]:
            src_im_path=os.path.join(im_dir,item)
            dst_im_path=os.path.join(im_dir,str(video_name)+"_"+str(obj_num),'img',item)
            if os.path.exists(src_im_path) and  not os.path.exists(dst_im_path):
                shutil.copy(src_im_path,dst_im_path)
            elif not os.path.exists(src_im_path):
                print("There isn't exist src_im_path")
                break;
            elif os.path.exists(dst_im_path):
                print("There is exist dst_im_path")
                break;
```

### 2. 为视频的第一帧画框，存储
- 根据每个目标的开始帧和结束帧，复制图片到单独的文件夹里，并重命名%04d.jpg (从0001.jpg开始)
- 显示每个目标的第一帧图，为目标画框，得到第一帧目标的xywh，并存储
- 作用是为直接使用ECO做准备

```python
import cv2
import numpy as np
import pandas as pd
import os

#  吊舱的测试视频有11个，这里选择是第几个视频，保存为num
video_num=1
num=video_num

#  视频存放的路径，一般得到的结果也存储到这个文件夹里，所以设置为主路径，也叫做视频的路径，因为这里主目录就是视频存放的目录
main_dir=r"E:\work\zmvision\12suo\videosamples"
video_dir=main_dir

#  读取每个目标的起始帧和结束帧的信息，先获取文本路径，再读取
info_stendframes_path=os.path.join(video_dir,'info_stendframes.txt')
info_stendframes=pd.read_csv(info_stendframes_path, sep=' |\t',index_col='object_num')

#  得到有多少个目标
sub_num=info_stendframes.shape[0]
#  print(sub_num)

#  为每个目标创建单独的文件夹，用于储存结果
for i in range(1,sub_num+1):
    if not os.path.exists(os.path.join(main_dir,str(num),str(num)+'_'+str(i),'img')):
        os.makedirs(os.path.join(main_dir,str(num),str(num)+'_'+str(i),'img'))

#  为每个目标定义一个p，用于得到在当前目标的第几帧
for i in range(1,sub_num+1):
    locals()['p'+str(i)]=1

#  获取视频，并得到视频的总帧数
capture = cv2.VideoCapture(os.path.join(video_dir,str(num)+'.avi'))
frames_num=capture.get(7)

#  遍历原始视频的每一帧，将相应的帧的图片复制到每个目标对应的文件夹
for i in range(1,int(frames_num)+1):
    ret,frame = capture.read()

    #  遍历每个目标，如果该帧的编号在某个目录的起始帧和结束帧中间，则写入
    #  用p来记录每个目标复制到哪一帧了（p从1开始）
    for num_object in range(1, sub_num + 1):
        if i>=info_stendframes.loc[num_object, "start_frame"] and i<info_stendframes.loc[num_object, "end_frame"]:
            p = locals()['p' + str(num_object)]
            #  将图片写入
            cv2.imwrite(os.path.join(r"E:\work\zmvision\12suo\videosamples",str(num),str(num)+'_'+str(num_object),'img',"%04d.jpg"%p), frame)
            locals()['p' + str(num_object)] = locals()['p' + str(num_object)] + 1

drawing = False
ix, iy,w,h = -1, -1,-1,-1
tempFlag = False
def draw_circle(event, x, y, flags, param):
    global ix, iy, drawing, mode, cap, template, tempFlag,w,h
    if event == cv2.EVENT_LBUTTONDOWN:
        tempFlag = True
        drawing = True
        ix, iy = x, y                        #  按下鼠标左键，用全局变量ix,iy记录下当前坐标点
        print("ix: "+ix)
        print("iy: "+iy)
    elif event== cv2.EVENT_LBUTTONUP:
        if drawing == True:
            drawing = False                  #  鼠标左键抬起，画出矩形框
            w=x-ix
            h=y-iy
            cv2.rectangle(frame,(ix,iy),(x,y),(0,255,0),1)
            print("w: "+w)
            print("h: "+h)

#  新建窗口。遍历每个目标的第一幅图像，画框，存储他们的起始坐标
cv2.namedWindow('0001')
cv2.setMouseCallback('0001',draw_circle)
for num_object in range(1, sub_num + 1):
    frame=cv2.imread(os.path.join(r"E:\work\zmvision\12suo\videosamples",str(num),str(num)+'_'+str(num_object),'img',"0001.jpg"))
    while True:
        cv2.imshow("0001",frame)
        k=cv2.waitKey(33)
        if k==32:
            break
        elif k==27 :
            frame = cv2.imread(os.path.join(r"E:\work\zmvision\12suo\videosamples", str(num), str(num) + '_' + str(num_object), 'img',
                             "0001.jpg"))
    f=open(os.path.join(r"E:\work\zmvision\12suo\videosamples",str(num),str(num)+'_'+str(num_object),"groundtruth_rect.txt"),'w')
    f.write('{0} {1} {2} {3}\n{4}'.format(ix,iy,w,h,locals()['p' + str(num_object)]-1))
    f.close()
```

### 3.视频根据起始帧和结束帧转图片
- 一个视频，知道了每个目标的起始帧和结束帧，将每个目标单独的图片放在文件夹
- 首先将视频转成图片
- 根据起始帧和结束帧复制图片

```python
import cv2
import pandas as pd
import os
import shutil


im=0
drawing = False
x_lt,y_lt,w,h=-1,-1,-1,-1
def draw_circle(event, x, y, flags, param):
    global x_lt,y_lt,w,h,drawing,im
    if event == cv2.EVENT_LBUTTONDOWN:
        drawing = True
        x_lt, y_lt = x, y                        #  按下鼠标左键，用全局变量ix,iy记录下当前坐标点
        print(str(x_lt))
        print(str(y_lt))

    elif event== cv2.EVENT_LBUTTONUP:
        if drawing == True:
            drawing = False                  #  鼠标左键抬起，画出矩形框
            w=x-x_lt
            h=y-y_lt
            cv2.rectangle(im,(x_lt,y_lt),(x,y),(0,255,0),1)
            print(str(x))
            print(str(y))

def draw_init_pos(im_dir):
    global im
    im_list = []  # 新建空链表
    for item in os.listdir(im_dir):
        if (item.endswith('.jpg')):
            im_list.append(item)
    im_list.sort(key=lambda x: int(x[:-4]))

    cv2.namedWindow(im_list[0])
    cv2.setMouseCallback(im_list[0], draw_circle)

    im_path=os.path.join(im_dir,im_list[0])
    im=cv2.imread(im_path)

    while True:
        cv2.imshow(im_list[0], im)
        k = cv2.waitKey(33)
        if k == 32:
            cv2.destroyWindow(im_list[0])
            break
        elif k == 27:
            im = cv2.imread(im_path)



video_name=1    #视频编号
video_path=r"E:\MyProjects\sampletest\1.avi"    #视频路径
im_dir=r"E:\MyProjects\sampletest\1"    #图片目录
frames_info_path=r"E:\MyProjects\sampletest\1\objs_frame_info.txt" #存放帧信息txt

# 1. 读取目标帧信息
objs_frame_info= pd.read_csv(frames_info_path,sep=' ', index_col='object_num')
objs_num=objs_frame_info.shape[0]  #行,目标个数

for obj_num in range(1, objs_num + 1):
    obj_dir=os.path.join(im_dir,str(video_name)+"_"+str(obj_num),'img')
    draw_init_pos(obj_dir)
    obj_groundtruth=os.path.join(im_dir,str(video_name)+"_"+str(obj_num),'groundtruth_rect.txt')
    f = open(obj_groundtruth,'w')
    f.write('{0} {1} {2} {3}'.format(x_lt,y_lt,w,h))
    f.close()
```
### 4. 制作效果视频
根据图片和目标坐标，最后制作成效果视频

```python
import cv2
import pandas as pd
import os
import shutil

video_name=1    #视频编号
video_path=r"E:\MyProjects\sampletest\1.avi"    #视频路径
im_dir=r"E:\MyProjects\sampletest\1"    #图片目录
frames_info_path=r"E:\MyProjects\sampletest\1\objs_frame_info.txt" #存放帧信息txt
video_info_path=r"E:\MyProjects\sampletest\video_info.txt"

#  读取该视频的信息，存储到video_info，包括：
#  video_num:   第几个视频
#  object_num:  第几个目标
#  frame_rate:  合成该视频的帧率
#  size_w： 视频的宽
#  size_h： 视频的高
video_info=pd.read_csv(video_info_path,index_col='video_num')
fps = video_info.loc[video_name,"frame_rate"]  # 视频每秒24帧
size = (video_info.loc[video_name,"size_w"], video_info.loc[video_name,"size_h"])  # 需要转为视频的图片的尺寸
video = cv2.VideoWriter(str(video_name)+".avi", cv2.VideoWriter_fourcc('X', 'V', 'I', 'D'), fps, size)

# 1. 读取目标帧信息
objs_frame_info= pd.read_csv(frames_info_path,sep=' ', index_col='object_num')
objs_num=objs_frame_info.shape[0]  #行,目标个数

im_list = []  # 新建空链表
for item in os.listdir(im_dir):
    if (item.endswith('.jpg')):  # 如果是.jpg文件，则放到filelist
           im_list.append(item)
im_list.sort(key=lambda x:int(x[:-4]))

for obj_num in range(1, objs_num + 1):
    pos_path=os.path.join(im_dir,str(video_name) + '_' + str(obj_num),"pos_result.txt")
    locals()['pos_result'+str(obj_num)]=pd.read_csv(pos_path,sep=' ', names=['x','y','w','h'])

for im_fullname in im_list:
    im_path = os.path.join(im_dir, im_fullname)  # 获取每张图片路径
    im = cv2.imread(im_path)  # 读取图片

    (im_name, extension) = os.path.splitext(im_fullname)
    cur_frame = int(im_name)

    for obj_num in range(1, objs_num + 1):
        if cur_frame >= objs_frame_info.loc[obj_num, "start_frame"] and cur_frame <= objs_frame_info.loc[
            obj_num, "end_frame"]:
            pos_reslut=locals()['pos_result' + str(obj_num)]
            pos_index=cur_frame-objs_frame_info.loc[obj_num, "start_frame"]
            x_lt = int(pos_reslut.loc[pos_index, "x"])
            y_lt = int(pos_reslut.loc[pos_index, "y"])
            x_rb = int(pos_reslut.loc[pos_index, "x"] + pos_reslut.loc[pos_index, "w"])
            y_rb = int(pos_reslut.loc[pos_index, "y"] + pos_reslut.loc[pos_index, "h"])

            cv2.rectangle(im, (x_lt, y_lt), (x_rb, y_rb), (0, 0, 255), 1)
    video.write(im)
video.release()
```

### 5.将ECO跟踪跑得的每个目标的结果坐标组合到一个视频里
```python
import cv2
import numpy as np
import pandas as pd
import os

#吊舱的测试视频有11个，这里选择是第几个视频，保存为num
video_num=4
num=video_num

#  读取该视频的信息，存储到video_info，包括：
#  video_num:   第几个视频
#  object_num:  第几个目标
#  frame_rate:  合成该视频的帧率
#  size_w： 视频的宽
#  size_h： 视频的高
video_info=pd.read_csv(r"E:\work\zmvision\12suo\picsamples\video_info.txt",index_col='video_num')

#   获得该视频的目标的个数，存放在sub_num
sub_num=video_info.loc[video_num,"object_num"]  #第n个总共有7个目标

#  主目录：存放该视频所有图片的目录，根据这些图片合成视频
main_dir=os.path.join(r'E:\work\zmvision\12suo\picsamples',str(num))
pic_dir=main_dir

#  存放每个目标的起始帧和结束帧的文本文件
#  将这些信息保存到info_stendframes
info_stendframes_path=os.path.join(pic_dir,'info_stendframes.txt')
info_stendframes=pd.read_csv(info_stendframes_path, sep=' |\t',index_col='object_num')
#   print(info_stendframes)
#   print(info_stendframes.loc[34,"start_frame"])

#   将主目录下所有以".jpg"的文件加入到filelist，排除其他文本文件和文件夹
filelist=[]     #  新建空链表
file_list = os.listdir(pic_dir)     #  首先获取所有文件
for i in file_list:
    if (i.endswith('.jpg')):        #  如果是.jpg文件，则放到filelist
        filelist.append(i)

#  每个目标都有很多坐标，将每个目标的坐标文件存到相应的data里面
#  使用p来记录已经到该目标的哪一帧了
for i in range(1,sub_num+1):
    loc_dir=os.path.join(pic_dir,str(num)+'_'+str(i),str(num)+'_'+str(i)+'.txt')
    locals()['data'+str(i)]=pd.read_csv(loc_dir, sep='\t', names=['y', 'x', 'h', 'w'])
    locals()['p'+str(i)]=-1

# 合成视频设置,包括帧率，尺寸，编码格式
fps = video_info.loc[video_num,"frame_rate"]  # 视频每秒24帧
size = (video_info.loc[video_num,"size_w"], video_info.loc[video_num,"size_h"])  # 需要转为视频的图片的尺寸
video = cv2.VideoWriter(str(num)+".avi", cv2.VideoWriter_fourcc('X', 'V', 'I', 'D'), fps, size)

i = 1
for item in filelist:   # 遍历所有图片
    pic_path=os.path.join(pic_dir, item)    #  获取每张图片路径
    img = cv2.imread(pic_path)          # 读取图片

    for num_object in range(1, sub_num+1):  #  遍历每个目标
        # 查看现在遍历到的原图是否有该目标。如果有，则将该目标的坐标画框合成到原图里
        if i >= info_stendframes.loc[num_object, "start_frame"] and i < info_stendframes.loc[num_object, "end_frame"]:
            locals()['p' + str(num_object)]=locals()['p' + str(num_object)]+1
            p=locals()['p' + str(num_object)]
            data=locals()['data' + str(num_object)]
            x_lt = int(data.loc[p, "x"] - data.loc[p, "w"] / 2)
            y_lt = int(data.loc[p, "y"] - data.loc[p, "h"] / 2)
            x_rb = int(data.loc[p, "x"] + data.loc[p, "w"] / 2)
            y_rb = int(data.loc[p, "y"] + data.loc[p, "h"] / 2)
            cv2.rectangle(img, (x_lt, y_lt), (x_rb, y_rb), (0, 255, 0), 2)
            print("x  :"+str(data.loc[p, "x"]))
            print("y  :" + str(data.loc[p, "y"]))
            font = cv2.FONT_HERSHEY_COMPLEX
            text = str(num_object)
            cv2.putText(img, text, (x_lt, y_lt), font, 0.7, (0, 0, 255), 1)

    '''
    cv2.imshow("aa", img)
    print(item)
    print(info_stendframes.loc[num_object, "start_frame"])
    while cv2.waitKey(0):
       break
    '''
    video.write(img)
    i = i + 1
    print(i)

video.release()
cv2.destroyAllWindows()
```

## 1.11.8 学习python
### 1. 我查询的函数
os.path.abspath(path)  返回绝对路径

**result = numpy.outer(a, b)** 用来求外积的，非常直观，比矩阵相乘简单

meshgrid: https://blog.csdn.net/sinat_29957455/article/details/78825945

### 2. error: ImportError: attempted relative import with no known parent package
>Relative imports use a module’s __name__ attribute to determine that module’s position in the package hierarchy. If the module’s name does not contain any package information (e.g. it is set to __main__ ) then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.
>相对导入通过使用模块的 __name__ 属性来确定模块在包层次结构中的位置。如果该模块的名称不包含任何包信息（例如，它被设置为 __main__ ），那么相对引用会认为这个模块就是顶级模块，而不管模块在文件系统上的实际位置。


换句话说，解决模块的算法是基于__name__和__package__变量的值。大部分时候，这些变量不包含任何包信息 ---- 比如：当 __name__ = __main__ 和 __package__ = None 时，python解释器不知道模块所属的包。在这种情况下，相对引用会认为这个模块就是顶级模块，而不管模块在文件系统上的实际位置。

为了演示这个原理，我们来更新一下代码：

- project/config.py

```python
print('__file__={0:<35} | __name__={1:<20} | __package__={2:<20}'.format(__file__,__name__,str(__package__)))
count = 5
```

- project/package/demo.py

```python
print('__file__={0:<35} | __name__={1:<20} | __package__={2:<20}'.format(__file__,__name__,str(__package__)))
from .. import config
print("The value of config.count is {0}".format(config.count))
```

再次尝试运行一下，会得到以下输出：

```python
E:\project> python demos/demo.py
__file__=demos/demo.py      | __name__=__main__    | __package__=None
Traceback (most recent call last):
  File "demos/demo.py", line 3, in <module>
    from .. import config
ImportError: attempted relative import with no known parent package
```

正如我们所看到的，python解释器没有关于模块所属的包的任何信息（ `__name__` = `__main__` 和 `__package__` = `None` ），因此它抛出了找不到父级包的异常。

#### 解决方案一

- 我们通过在其中创建一个新的空 `__init__.py` 文件来将项目目录转换为一个包。
- 我们在项目目录的父目录中创建一个文件 `main.py`

```shell
toplevel
├── main.py
└── project
  ├── __init__.py
  ├── config.py
  └── demos
      ├── __init__.py
      └── demo.py
```

- toplevel/main.py

```python
print('__file__={0:<35} | __name__={1:<20} | __package__={2:<20}'.format(__file__,__name__,str(__package__)))
import project.demos.demo
```

执行一下新的示例，输出如下：

```python
E:\toplevel>python main.py
__file__=main.py                             | __name__=__main__             | __package__=None
__file__=E:\toplevel\project\demos\demo.py   | __name__=project.demos.demo   | __package__=project.demos
__file__=E:\toplevel\project\config.py       | __name__=project.config       | __package__=project
The value of config.count is 5
```

在 `main.py` 中导入 `project.demos.demo` 会设置相对引用的包信息（ `__name__` 和 `__package__` 变量）。现在，python解释器可以成功解析 `project\demos\demo.py` 中的相对引用了。

#### 解决方案二

- 我们通过在 `project` 文件夹中创建一个新的空 `__init__.py` 来将 `project` 目录转换为一个包。
- 在 `toplevel` 目录下通过 `-m` 参数来调用python解释器，去执行 `project.demos.demo`[[1\]](https://blog.csdn.net/nigelyq/article/details/78930330#note1)

```shell
toplevel
└── project
  ├── __init__.py
  ├── config.py
  └── demos
      ├── __init__.py
      └── demo.py
```

再次执行：

```python
E:\toplevel>python -m project.demos.demo
__file__=E:\toplevel\project\demos\demo.py   | __name__=__main__        | __package__=project.demos
__file__=E:\toplevel\project\config.py       | __name__=project.config  | __package__=project
The value of config.count is 5
```

运行该命令将自动设置包信息（`__package__`变量）。现在，python解释器可以成功解析 `project\ demos\demo.py` 中的相对引用了（甚至认为 `__name __` = `__ main__` ）。

[1] **译者注：注意使用 `-m` 参数的时候，后面指定的执行文件没有 `.py` 后缀**

#### 解决方案三

Here are 3 solutions to your problem

1. You can add the directory containing the file you with to import to your path and then import the file. like this

```py
import sys  
sys.path.insert(0, '/path/to/application/app/folder')

import file
```

1. You can create a local module by having an empty `__init__.py` file in the folder you want to import. There are some [weird rules](https://docs.python.org/3/tutorial/modules.html) regarding the folder hierarchy that you have to take into consideration.
2. You can create a module for the file you wish to import and install it globally.

### 3.学习了两个很好的资料

Python 入门笔记

李沐-pytorch改写版以及程序

深度学习入门之pytorch code-of-learn-deep-learning-with-pytorch-master





